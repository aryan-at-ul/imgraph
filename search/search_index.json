{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IMGRAPH","text":""},{"location":"#used-for-converting-image-to-graph-uses-superpixel-method-for-node-creation-extract-features-from-cnn-models","title":"Used for converting image to graph, uses superpixel method for node creation, extract features from CNN models.","text":"<p>Example Usage: </p> <pre><code>from imgraph.pipeline import create_graph_pipleline\n\npath = \"path/to/image\"\n\ncreate_graph_pipleline(path, 'classification', 'rag', 'resnet18', 10)\n</code></pre>"},{"location":"#above-code-will-create-a-graph-from-the-image-and-save-it-in-the-directory-cacheimgraph-or-directory-specified-by-the-user-in-enviornment-variable-imgraph_home","title":"Above code will create a graph from the image and save it in the directory .~/cache/imgraph or directory specified by the user in enviornment variable IMGRAPH_HOME.","text":""},{"location":"#expected-input-folder-structure","title":"Expected input folder structure:","text":"<pre><code>image_folder\n\u251c\u2500\u2500 test\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 class1\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 class2\n\u251c\u2500\u2500 train\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 class1\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 class2\n\u2514\u2500\u2500 val\n    \u251c\u2500\u2500 class1\n    \u2514\u2500\u2500 class2\n</code></pre>"},{"location":"#the-graph-will-be-saved-in-the-pyg-data-format-or-pickle-format","title":"The graph will be saved in the PyG Data format or pickle format.","text":""},{"location":"#to-install-pytorch-geometric-dependencies-please-follow-the-instructions-here-pyg-installation-or-use-the-following-code-snippet","title":"To install pytorch geometric dependencies, please follow the instructions here: PyG installation or use the following code snippet:","text":""},{"location":"#to-install-full-dependeciens-install-using-setuppy-with-full-dependencies-flag-its-slow-but-will-install-all-dependencies","title":"To install full dependeciens install using setup.py with full-dependencies flag (its slow, but will install all dependencies)","text":"<pre><code>import torch\n\ndef format_pytorch_version(version):\nreturn version.split('+')[0]\n\nTORCH_version = torch.__version__\nTORCH = format_pytorch_version(TORCH_version)\n\ndef format_cuda_version(version):\nreturn 'cu' + version.replace('.', '')\n\nCUDA_version = torch.version.cuda\nCUDA = format_cuda_version(CUDA_version)\n\n!pip install torch-scatter     -f https://pytorch-geometric.com/whl/torch-{TORCH}+{CUDA}.html\n!pip install torch-sparse      -f https://pytorch-geometric.com/whl/torch-{TORCH}+{CUDA}.html\n!pip install torch-cluster     -f https://pytorch-geometric.com/whl/torch-{TORCH}+{CUDA}.html\n!pip install torch-spline-conv -f https://pytorch-geometric.com/whl/torch-{TORCH}+{CUDA}.html\n!pip install torch-geometric \n</code></pre>"},{"location":"data/","title":"Reference","text":""},{"location":"data/#data-module","title":"Data module","text":""},{"location":"data/#imgraph.data.graph_generator","title":"<code>graph_generator(img, model_name, name, class_name, class_map, n_segments=10, compactness=10, sigma=1, multichannel=True, task='classification', type=True)</code>","text":"<p>img: numpy array of the image</p> Name Type Description Default <code>segments</code> <p>numpy array of the segments of the image</p> required <code>name</code> <code>str</code> <p>name of the graph</p> required <code>task</code> <p>classification or regression</p> <code>'classification'</code> <code>type</code> <p>type of the graph train/test</p> <code>True</code> Source code in <code>imgraph/data/make_graph.py</code> <pre><code>def graph_generator(img : np.ndarray, model_name : str, name : str, class_name : str, class_map : dict, n_segments = 10, compactness = 10, sigma = 1, multichannel = True, task = 'classification', type = True):\n\"\"\"\n    Args: img: numpy array of the image\n            segments: numpy array of the segments of the image\n            name: name of the graph\n            task: classification or regression\n            type: type of the graph train/test\n    Returns: networkx graph\n    \"\"\"\n    # print(\"Generating graph for image: \", name, \" with model: \", model_name)\n    start_time = time.time()\n    G2 = nx.Graph()\n    model,feature_extractor = get_feture_extractor_model(model_name)\n    if len(img.shape) &lt; 3:\n        img = np.stack((img,)*3, axis=-1)\n    seg_imgs = []\n    G, segments  = make_graph(img, name, n_segments, compactness, sigma, multichannel, task, type)\n    for (i, segVal) in enumerate(np.unique(segments)):\n        mask = np.zeros(img.shape[:2], dtype = \"uint8\")\n        mask[segments == segVal] = 255\n        segimg = cv2.cvtColor(cv2.bitwise_and(img, img, mask = mask), cv2.COLOR_BGR2RGB)\n        segimg = cv2.bitwise_and(img, img, mask = mask)\n        gray = cv2.cvtColor(segimg, cv2.COLOR_BGR2GRAY)\n        thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_OTSU + cv2.THRESH_BINARY)[1]\n        cnts = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        cnts = cnts[0] if len(cnts) == 2 else cnts[1]\n        cnts = sorted(cnts, key=cv2.contourArea, reverse=True)\n        seg = segimg.copy()\n        for c in cnts:\n            x,y,w,h = cv2.boundingRect(c)\n            seg = img[y:y+h, x:x+w]\n            break\n        seg = cv2.cvtColor(seg, cv2.COLOR_BGR2RGB)\n        G.nodes[segVal]['img'] = seg\n        seg_imgs.append([seg,segVal])\n    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:\n        futures = [executor.submit(feature_from_img, seg_img[0],model, feature_extractor ,seg_img[1])  for  i,seg_img in enumerate(seg_imgs)]\n        for future in concurrent.futures.as_completed(futures):\n            try:\n                img_fet,i = future.result()\n                G2.add_node(i,x = img_fet)\n            except Exception as exc:\n                print(f'generated an exception: {exc}')\n                print(traceback.format_exc())\n\n    end_time = time.time()\n    # print(f\"{name} total time take per image is {end_time - start_time}\")\n    edges = G.edges\n    for e in edges:\n        G2.add_weighted_edges_from([(e[0],e[1],G[e[0]][e[1]]['weight'])])\n\n    data = None\n    if task == 'classification':\n        data = load_and_transform(G2, name, class_map[class_name])\n\n    return G2,name,data\n</code></pre>"},{"location":"data/#imgraph.data.image_transform_slic","title":"<code>image_transform_slic(img, n_segments=10, compactness=10, sigma=0, multichannel=True)</code>","text":"<p>img: numpy array of the image</p> Name Type Description Default <code>n_segments</code> <p>number of segments</p> <code>10</code> <code>compactness</code> <p>compactness of the segments</p> <code>10</code> <code>sigma</code> <p>sigma for the filter</p> <code>0</code> <code>multichannel</code> <p>if the image is multichannel</p> <code>True</code> Source code in <code>imgraph/data/make_graph.py</code> <pre><code>def image_transform_slic(img : np.ndarray, n_segments = 10, compactness = 10, sigma = 0, multichannel = True):\n\"\"\"\n    Args: img: numpy array of the image\n            n_segments: number of segments\n            compactness: compactness of the segments\n            sigma: sigma for the filter\n            multichannel: if the image is multichannel\n    Returns: numpy array of the image/ segments of the image\n    \"\"\"\n    segments = slic(img, n_segments = n_segments, compactness = compactness, sigma = sigma)\n    return segments\n</code></pre>"},{"location":"data/#imgraph.data.make_edges","title":"<code>make_edges(img, segments, task='classification', type=True)</code>","text":"<p>img: numpy array of the image</p> Name Type Description Default <code>segments</code> <code>np.ndarray</code> <p>numpy array of the segments of the image</p> required <code>name</code> <p>name of the graph</p> required <code>task</code> <p>classification or regression</p> <code>'classification'</code> <code>type</code> <p>type of the graph train/test</p> <code>True</code> Source code in <code>imgraph/data/make_graph.py</code> <pre><code>def make_edges(img : np.ndarray, segments : np.ndarray, task = 'classification', type = True):\n\"\"\"\n    Args: img: numpy array of the image\n            segments: numpy array of the segments of the image\n            name: name of the graph\n            task: classification or regression\n            type: type of the graph train/test\n    Returns: RAG recency graph\n    \"\"\"\n    rag = graph.rag_mean_color(img, segments,mode='distance')\n    return rag\n</code></pre>"},{"location":"datasets/","title":"Reference","text":""},{"location":"datasets/#available-benchmark-datasets","title":"Available benchmark datasets","text":""},{"location":"datasets/#imgraph.datasets.get_minst_dataset","title":"<code>get_minst_dataset()</code>","text":"<p>Returns:</p> Type Description <p>A train_dataset and a test_dataset</p> Source code in <code>imgraph/datasets/mnist_dataset.py</code> <pre><code>def get_minst_dataset():\n\"\"\"\n    Args:\n        None\n    Returns:\n        A train_dataset and a test_dataset\n    \"\"\"\n    print(\"Getting minst dataset\")\n    train_loader_url = \"https://drive.google.com/uc?export=download&amp;confirm=yes&amp;id=1lORmY8srDFTm6a8yqzUOLrrvPOkoUZQ0\"\n    test_loader_url = \"https://drive.google.com/uc?export=download&amp;confirm=yes&amp;id=1fwkebInpfzHHv9M60zvH3YRPbEVBg53L\"\n    path = osp.join(DEFAULT_CACHE_DIR, 'output')\n    if os.environ.get(ENV_IMGRAPH_HOME):\n        path  = osp.join(os.environ.get(ENV_IMGRAPH_HOME), 'output')\n    train_filename = osp.expanduser(osp.join(path, 'mnist_trainloader.pkl'))\n    test_filename = osp.expanduser(osp.join(path, 'mnist_testloader.pkl'))\n\n    path = osp.expanduser(path)\n\n    # os.system(f\"curl -o {train_filename} -L '{train_loader_url}'\")\n    # os.system(f\"curl -o {test_filename} -L '{test_loader_url}'\")\n    #url : str, path : str, filename : Optional[str] = None\n    download_from_url(train_loader_url,path,'mnist_trainloader.pkl')\n    download_from_url(test_loader_url,path,'mnist_testloader.pkl')\n    #filepath = osp.join(path, filename)\n    train_loader = None\n    test_loader = None\n    print(\"Loading minst dataset\")\n    with open(train_filename, 'rb') as f:\n        train_loader = pickle.load(f)\n\n    with open(test_filename, 'rb') as f:\n        test_loader = pickle.load(f)\n\n    return train_loader.dataset,test_loader.dataset\n</code></pre>"},{"location":"datasets/#imgraph.datasets.get_pneumonia_dataset","title":"<code>get_pneumonia_dataset(super_pixels, feature_extractor)</code>","text":"<p>Download the pneumonia datasets</p> <p>Parameters:</p> Name Type Description Default <code>super_pixels</code> <code>int</code> <p>The number of super pixels to be used in the graph</p> required <code>feature_extractor</code> <code>str</code> <p>The feature extractor to be used to create the graph. Currently only 'resnet18/efficientnet/densenet121' is supported</p> required <p>Returns:</p> Type Description <code>list</code> <p>Pneumonia dataset</p> Source code in <code>imgraph/datasets/pneumonia_dataset.py</code> <pre><code>def get_pneumonia_dataset(super_pixels : int, feature_extractor : str) -&gt; list:\n\"\"\"\n    Download the pneumonia datasets\n    Args:\n        super_pixels (int): The number of super pixels to be used in the graph\n        feature_extractor (str): The feature extractor to be used to create the graph. Currently only 'resnet18/efficientnet/densenet121' is supported\n\n    Returns:\n        Pneumonia dataset\n    \"\"\"\n\n\n    train_loader_url = pneumonia_dataset_url[f\"train_dataloader_{super_pixels}_{feature_extractor}\"]\n    test_loader_url = pneumonia_dataset_url[f\"test_dataloader_{super_pixels}_{feature_extractor}\"]\n\n\n    path = osp.join(DEFAULT_CACHE_DIR, 'output')\n    if os.environ.get(ENV_IMGRAPH_HOME):\n        path = osp.join(os.environ.get(ENV_IMGRAPH_HOME), 'output')\n\n    path = osp.expanduser(path)\n\n    train_filename = osp.expanduser(osp.join(path, f'train_dataloader_{super_pixels}_{feature_extractor}.pkl'))\n    test_filename = osp.expanduser(osp.join(path, f'test_dataloader_{super_pixels}_{feature_extractor}.pkl'))\n\n\n    download_from_url(train_loader_url, path, f'train_dataloader_{super_pixels}_{feature_extractor}.pkl')\n    download_from_url(test_loader_url, path, f'test_dataloader_{super_pixels}_{feature_extractor}.pkl')\n    #filepath = osp.join(path, filename)\n\n    train_loader = None\n    test_loader = None\n\n    print(\"Loading Pneumonia dataset\")\n    with open(train_filename, 'rb') as f:\n        train_loader = pickle.load(f)\n\n    with open(test_filename, 'rb') as f:\n        test_loader = pickle.load(f)\n\n    return train_loader.dataset,test_loader.dataset\n</code></pre>"},{"location":"pipeline/","title":"Reference","text":""},{"location":"pipeline/#imgraph-image-graphs","title":"imgraph - Image Graphs","text":""},{"location":"pipeline/#imgraph.pipeline.create_graph_pipleline","title":"<code>create_graph_pipleline(path, task, graph_method, feature_extractor, node_count=10, **kwargs)</code>","text":"<p>Create a graph pipeline from a folder of images</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the folder containing the images</p> required <code>task</code> <code>str</code> <p>The task to be performed on the images. Currently only classification is supported</p> required <code>graph_method</code> <code>str</code> <p>The method to be used to create the graph. Currently only 'SLIC' is supported</p> required <code>feature_extractor</code> <code>str</code> <p>The feature extractor to be used to create the graph. Currently only 'resnet18/efficientnet/densenet121' is supported</p> required <code>node_count</code> <code>int</code> <p>The number of nodes in the graph</p> <code>10</code> <code>kwargs</code> <p>Additional arguments to be passed to the graph creation method, like the number of prcoessors to be used</p> <code>{}</code> <p>Returns:</p> Type Description <p>A dictionary of the images with the graph segment of the image, defaut ~/.cache/imgraph/output else as specified in the environment variable IMGRAPH_HOME</p> Source code in <code>imgraph/pipeline/folder_pipeline.py</code> <pre><code>def create_graph_pipleline(path : str, task : str, graph_method : str, feature_extractor, node_count = 10,  **kwargs):\n\n\"\"\" Create a graph pipeline from a folder of images\n    Args:\n        path (str): Path to the folder containing the images\n        task (str): The task to be performed on the images. Currently only classification is supported\n        graph_method (str): The method to be used to create the graph. Currently only 'SLIC' is supported\n        feature_extractor (str): The feature extractor to be used to create the graph. Currently only 'resnet18/efficientnet/densenet121' is supported\n        node_count (int): The number of nodes in the graph\n        kwargs: Additional arguments to be passed to the graph creation method, like the number of prcoessors to be used\n    Returns:\n        A dictionary of the images with the graph segment of the image, defaut ~/.cache/imgraph/output else as specified in the environment variable IMGRAPH_HOME\n\n    \"\"\"\n\n\n    print(\"Creating graph pipeline\")\n    global output_dir\n    global class_map\n    output_dir = osp.join(DEFAULT_CACHE_DIR, 'output')\n    if os.environ.get(ENV_IMGRAPH_HOME):\n        makedirs(os.environ.get(ENV_IMGRAPH_HOME))\n        output_dir = osp.join(os.environ.get(ENV_IMGRAPH_HOME), 'output')\n    else:\n        makedirs(DEFAULT_CACHE_DIR)\n\n\n    if task == 'classification':\n        image_path = path \n        image_files = get_directories_from_path(image_path)\n        image_categories = get_file_categoryies_from_path(image_files)\n        file_path_dictionary = {}\n        for train_test_val in image_categories:\n            cat_path = osp.join(image_path, train_test_val)\n            class_dirs = get_directories_from_path(cat_path)\n            classes = get_file_categoryies_from_path(class_dirs)\n            label_encoder.fit(classes)\n            class_map = dict(zip(classes,label_encoder.transform(classes)))\n            if train_test_val not in file_path_dictionary.keys():\n                file_path_dictionary[train_test_val] = {}\n            for class_name in classes:\n                class_files = []\n                class_path = osp.join(cat_path, class_name)\n                class_files = get_files_from_path(class_path)\n                if class_name not in file_path_dictionary[train_test_val].keys():\n                    file_path_dictionary[train_test_val][class_name] = {}\n                file_path_dictionary[train_test_val][class_name] = class_files\n        img_and_name = read_images_in_parallel(file_path_dictionary)\n        graph_and_name = get_graph(img_and_name, class_map,feature_extractor, node_count)\n        return graph_and_name\n    else:\n        raise ValueError(f'Invalid task: {task}')\n</code></pre>"},{"location":"pipeline/#imgraph.pipeline.load_saved_datasets","title":"<code>load_saved_datasets(dataset_name, super_pixels=10, feature_extractor='resnet18', root=None)</code>","text":"<p>Loads the dataset from the local cache.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>root</code> <code>str</code> <p>The root directory where the dataset should be saved. (default: :obj:<code>None</code>)</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>The dataset object.</p> Source code in <code>imgraph/pipeline/from_dataset.py</code> <pre><code>def load_saved_datasets(dataset_name: str, super_pixels : Optional[str] = 10, feature_extractor : Optional[str] = 'resnet18' ,root: Optional[str] = None) -&gt; None:\nr\"\"\"Loads the dataset from the local cache.\n\n    Args:\n        dataset_name (str): The name of the dataset.\n        root (str, optional): The root directory where the dataset should be saved.\n            (default: :obj:`None`)\n    Returns:\n        The dataset object.\n    \"\"\"\n\n    if dataset_name.lower() == 'mnist':\n        train_dataset, test_dataset = get_minst_dataset()\n        return train_dataset, test_dataset\n\n    if dataset_name.lower() == 'pneumonia':\n        train_dataset, test_dataset = get_pneumonia_dataset(super_pixels,feature_extractor)\n        return train_dataset, test_dataset\n</code></pre>"},{"location":"reader/","title":"Reference","text":""},{"location":"reader/#reader-module","title":"Reader module","text":""},{"location":"reader/#imgraph.reader.get_directories_from_path","title":"<code>get_directories_from_path(path)</code>","text":"<p>Get all directories from a path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to a local folder. this folder should contain train, test, validation folders of images of graphs </p> required <p>Returns:</p> Type Description <p>A list of directories. The reruned list is sorted used to iterate through each folder.</p> Source code in <code>imgraph/reader/read_directory.py</code> <pre><code>def get_directories_from_path(path):\n\"\"\"Get all directories from a path.\n    Args:\n        path (str): The path to a local folder. this folder should contain train, test, validation folders of images of graphs \n    Returns:\n        A list of directories. The reruned list is sorted used to iterate through each folder.\n    \"\"\"\n    return [os.path.join(path, f) for f in os.listdir(path) if os.path.isdir(os.path.join(path, f)) and not f.startswith('__')]\n</code></pre>"},{"location":"reader/#imgraph.reader.get_file_categoryies_from_path","title":"<code>get_file_categoryies_from_path(path_list)</code>","text":"<p>Get all directories from a path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to a local folder. this folder should contain train, test, validation folders of images of graphs </p> required <p>Returns:</p> Type Description <p>A list of directories. Returns available catgory names, test, train, val, or class names.</p> Source code in <code>imgraph/reader/read_directory.py</code> <pre><code>def get_file_categoryies_from_path(path_list):\n\"\"\"Get all directories from a path.\n    Args:\n        path (str): The path to a local folder. this folder should contain train, test, validation folders of images of graphs \n    Returns:\n        A list of directories. Returns available catgory names, test, train, val, or class names.\n    \"\"\"\n    return [f.split('/')[-1] for f in path_list]\n</code></pre>"},{"location":"reader/#imgraph.reader.get_files_from_path","title":"<code>get_files_from_path(folderpath)</code>","text":"<p>Get all files from a path.</p> <p>Parameters:</p> Name Type Description Default <code>folderpath</code> <code>str</code> <p>The path to a local folder. this folder should contain train, test, validation folders of images of graphs </p> required <p>Returns:</p> Type Description <p>A list of files. The reruned list is sorted used to iterate through each folder.</p> Source code in <code>imgraph/reader/read_directory.py</code> <pre><code>def get_files_from_path(folderpath):\n\"\"\"Get all files from a path.\n    Args:\n        folderpath (str): The path to a local folder. this folder should contain train, test, validation folders of images of graphs \n    Returns:\n        A list of files. The reruned list is sorted used to iterate through each folder.\n    \"\"\"\n    return [os.path.join(folderpath, f) for f in os.listdir(folderpath) if os.path.isfile(os.path.join(folderpath, f))]\n</code></pre>"},{"location":"reader/#imgraph.reader.get_files_from_path_with_extension","title":"<code>get_files_from_path_with_extension(folderpath, extension)</code>","text":"<p>Get all files from a path.</p> <p>Parameters:</p> Name Type Description Default <code>folderpath</code> <code>str</code> <p>The path to a local folder. this folder should contain train, test, validation folders of images of graphs </p> required <p>Returns:</p> Type Description <p>A list of files. The reruned list is sorted used to iterate through each folder.</p> Source code in <code>imgraph/reader/read_directory.py</code> <pre><code>def get_files_from_path_with_extension(folderpath, extension):\n\"\"\"Get all files from a path.\n    Args:\n        folderpath (str): The path to a local folder. this folder should contain train, test, validation folders of images of graphs \n    Returns:\n        A list of files. The reruned list is sorted used to iterate through each folder.\n    \"\"\"\n    return [os.path.join(folderpath, f) for f in os.listdir(folderpath) if os.path.isfile(os.path.join(folderpath, f)) and f.endswith(extension)]\n</code></pre>"},{"location":"reader/#imgraph.reader.read_graph","title":"<code>read_graph(path)</code>","text":"<p>Reads a graph from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to a local graph file.</p> required <p>Returns:</p> Type Description <p>A networkx graph.</p> Source code in <code>imgraph/reader/read_files.py</code> <pre><code>def read_graph(path):\n\"\"\"Reads a graph from a file.\n    Args:\n        path (str): The path to a local graph file.\n    Returns:\n        A networkx graph.\n    \"\"\"\n    return nx.read_gpickle(path)\n</code></pre>"},{"location":"reader/#imgraph.reader.read_image","title":"<code>read_image(path, name, backend='PIL', **kwargs)</code>","text":"<p>Reads an image from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to a local image file.</p> required <p>Returns:</p> Type Description <p>A PIL image.</p> Source code in <code>imgraph/reader/read_files.py</code> <pre><code>def read_image(path, name : str ,backend='PIL', **kwargs):\n\"\"\"Reads an image from a file.\n    Args:\n        path (str): The path to a local image file.\n    Returns:\n        A PIL image.\n    \"\"\"\n    image = imread(path)\n    height, widht = 0,0\n    if len(image.shape) &gt;= 3:\n        height, width, channel = image.shape\n    else:\n        height,width = image.shape\n    #height, width = image.shape\n    # image = image[0:height, 10:width-10]\n    try:\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        image = cv2.resize(image, (500, 500))\n    except Exception as e:\n        print(\"Error in resizing image: \", name, \" with error: \", e)\n    # image = img_as_float(image)\n    return image,name\n</code></pre>"},{"location":"reader/#imgraph.reader.read_pickle_file","title":"<code>read_pickle_file(path)</code>","text":"<p>Reads a pickle file from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to a local pickle file.</p> required <p>Returns:</p> Type Description <p>A pickle file.</p> Source code in <code>imgraph/reader/read_files.py</code> <pre><code>def read_pickle_file(path):\n\"\"\"Reads a pickle file from a file.\n    Args:\n        path (str): The path to a local pickle file.\n    Returns:\n        A pickle file.\n    \"\"\"\n\n    with open(path, 'rb') as f:\n        return pickle.load(f)\n</code></pre>"},{"location":"writer/","title":"Reference","text":""},{"location":"writer/#writer-module","title":"Writer module","text":""},{"location":"writer/#imgraph.writer.download_from_url","title":"<code>download_from_url(url, path, filename=None)</code>","text":"<p>Downloads a file from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to download from.</p> required <code>path</code> <code>str</code> <p>The path to save the file to.</p> required Source code in <code>imgraph/writer/write_files.py</code> <pre><code>def download_from_url(url : str, path : str, filename : Optional[str] = None):\n\"\"\"Downloads a file from a URL.\n    Args:\n        url (str): The URL to download from.\n        path (str): The path to save the file to.\n    \"\"\"\n    if filename is None:\n        filename = url.rpartition('/')[2]\n        filename = filename if filename[0] == '?' else filename.split('?')[0]\n\n    filepath = osp.join(path, filename)\n\n    if osp.exists(filepath):  \n        return filepath\n\n    makedirs(path)\n\n    context = ssl._create_unverified_context()\n    data = urllib.request.urlopen(url, context=context)\n\n    with open(filepath, 'wb') as f:\n        # workaround for https://bugs.python.org/issue42853\n        while True:\n            chunk = data.read(10 * 1024 * 1024)\n            if not chunk:\n                break\n            f.write(chunk)\n\n    return filepath\n</code></pre>"},{"location":"writer/#imgraph.writer.write_dataloader","title":"<code>write_dataloader(dataloader, path)</code>","text":"<p>Writes a dataloader to a file.</p> <p>Parameters:</p> Name Type Description Default <code>dataloader</code> <code>torch dataloader</code> <p>The dataloader to write.</p> required <code>path</code> <code>str</code> <p>The path to a local dataloader file.</p> required Source code in <code>imgraph/writer/write_files.py</code> <pre><code>def write_dataloader(dataloader, path):\n\"\"\"Writes a dataloader to a file.\n    Args:\n        dataloader (torch dataloader): The dataloader to write.\n        path (str): The path to a local dataloader file.\n    \"\"\"\n    with open(path, 'wb') as f:\n        pickle.dump(dataloader, f)\n</code></pre>"},{"location":"writer/#imgraph.writer.write_graph","title":"<code>write_graph(graph, path)</code>","text":"<p>Writes a graph to a file.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>networkx graph</code> <p>The graph to write.</p> required <code>path</code> <code>str</code> <p>The path to a local graph file.</p> required Source code in <code>imgraph/writer/write_files.py</code> <pre><code>def write_graph(graph, path):\n\"\"\"Writes a graph to a file.\n    Args:\n        graph (networkx graph): The graph to write.\n        path (str): The path to a local graph file.\n    \"\"\"\n    print(\"writing graph to file\", path)\n    nx.write_gpickle(graph, osp.expanduser(path))\n</code></pre>"},{"location":"writer/#imgraph.writer.write_image","title":"<code>write_image(img, path)</code>","text":"<p>Writes an image to a file.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>PIL image</code> <p>The image to write.</p> required <code>path</code> <code>str</code> <p>The path to a local image file.</p> required <p>Todo: support other image formats.</p> Source code in <code>imgraph/writer/write_files.py</code> <pre><code>def write_image(img, path):\n\"\"\"Writes an image to a file.\n    Args:\n        img (PIL image): The image to write.\n        path (str): The path to a local image file.\n    Todo: support other image formats.\n    \"\"\"\n    img.save(path)\n</code></pre>"},{"location":"writer/#imgraph.writer.write_pickle_file","title":"<code>write_pickle_file(obj, path)</code>","text":"<p>Writes a pickle file to a file.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The object to write.</p> required <code>path</code> <code>str</code> <p>The path to a local pickle file.</p> required Source code in <code>imgraph/writer/write_files.py</code> <pre><code>def write_pickle_file(obj, path):\n\"\"\"Writes a pickle file to a file.\n    Args:\n        obj (object): The object to write.\n        path (str): The path to a local pickle file.\n    \"\"\"\n    with open(path, 'wb') as f:\n        pickle.dump(obj, f)\n</code></pre>"},{"location":"writer/#imgraph.writer.write_pyg_data","title":"<code>write_pyg_data(data, path)</code>","text":"<p>Writes a PyG data object to a file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>PyG data object</code> <p>The data object to write.</p> required <code>path</code> <code>str</code> <p>The path to a local PyG data file.</p> required Source code in <code>imgraph/writer/write_files.py</code> <pre><code>def write_pyg_data(data, path):\n\"\"\"Writes a PyG data object to a file.\n    Args:\n        data (PyG data object): The data object to write.\n        path (str): The path to a local PyG data file.\n    \"\"\"\n    torch.save(data, osp.expanduser(path))\n</code></pre>"}]}