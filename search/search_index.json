{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IMGRAPH","text":""},{"location":"#used-for-converting-image-to-graph-uses-superpixel-method-for-node-creation-extract-features-from-cnn-models","title":"Used for converting image to graph, uses superpixel method for node creation, extract features from CNN models.","text":"<p>Example Usage: </p> <pre><code>from imgraph.pipeline import create_graph_pipleline\n\npath = \"path/to/image\"\n\ncreate_graph_pipleline(path, 'classification', 'rag', 'resnet18', 10)\n</code></pre>"},{"location":"#above-code-will-create-a-graph-from-the-image-and-save-it-in-the-directory-cacheimgraph-or-directory-specified-by-the-user-in-enviornment-variable-imgraph_home","title":"Above code will create a graph from the image and save it in the directory .~/cache/imgraph or directory specified by the user in enviornment variable IMGRAPH_HOME.","text":""},{"location":"#expected-input-folder-structure","title":"Expected input folder structure:","text":"<pre><code>    image_folder\n    \u251c\u2500\u2500 test\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 class1\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 class2\n    \u251c\u2500\u2500 train\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 class1\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 class2\n    \u2514\u2500\u2500 val\n        \u251c\u2500\u2500 class1\n        \u2514\u2500\u2500 class2\n</code></pre>"},{"location":"#the-graph-will-be-saved-in-the-pyg-data-format-or-pickle-format","title":"The graph will be saved in the PyG Data format or pickle format.","text":""},{"location":"#to-install-pytorch-geometric-dependencies-please-follow-the-instructions-here-pyg-installation-or-use-the-following-code-snippet","title":"To install pytorch geometric dependencies, please follow the instructions here: PyG installation or use the following code snippet:","text":""},{"location":"#to-install-full-dependeciens-install-using-setuppy-with-full-dependencies-flag-its-slow-but-will-install-all-dependencies","title":"To install full dependeciens install using setup.py with full-dependencies flag (its slow, but will install all dependencies)","text":"<p> import torch</p> <p>def format_pytorch_version(version): return version.split('+')[0]</p> <p>TORCH_version = torch.version TORCH = format_pytorch_version(TORCH_version)</p> <p>def format_cuda_version(version): return 'cu' + version.replace('.', '')</p> <p>CUDA_version = torch.version.cuda CUDA = format_cuda_version(CUDA_version)</p> <p>!pip install torch-scatter     -f https://pytorch-geometric.com/whl/torch-{TORCH}+{CUDA}.html !pip install torch-sparse      -f https://pytorch-geometric.com/whl/torch-{TORCH}+{CUDA}.html !pip install torch-cluster     -f https://pytorch-geometric.com/whl/torch-{TORCH}+{CUDA}.html !pip install torch-spline-conv -f https://pytorch-geometric.com/whl/torch-{TORCH}+{CUDA}.html !pip install torch-geometric </p> <p>```</p>"},{"location":"api/","title":"Reference","text":""},{"location":"api/#imgraph-image-graphs","title":"imgraph - Image Graphs","text":""},{"location":"api/#imgraph.pipeline.create_graph_pipleline","title":"<code>create_graph_pipleline(path, task, graph_method, feature_extractor, node_count=10, **kwargs)</code>","text":"<p>Create a graph pipeline from a folder of images</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the folder containing the images</p> required <code>task</code> <code>str</code> <p>The task to be performed on the images. Currently only classification is supported</p> required <code>graph_method</code> <code>str</code> <p>The method to be used to create the graph. Currently only 'SLIC' is supported</p> required <code>feature_extractor</code> <code>str</code> <p>The feature extractor to be used to create the graph. Currently only 'resnet18/efficientnet/densenet121' is supported</p> required <code>node_count</code> <code>int</code> <p>The number of nodes in the graph</p> <code>10</code> <code>kwargs</code> <p>Additional arguments to be passed to the graph creation method, like the number of prcoessors to be used</p> <code>{}</code> <p>Returns:</p> Type Description <p>A dictionary of the images with the graph segment of the image, defaut ~/.cache/imgraph/output else as specified in the environment variable IMGRAPH_HOME</p> Source code in <code>imgraph/pipeline/folder_pipeline.py</code> <pre><code>def create_graph_pipleline(path : str, task : str, graph_method : str, feature_extractor, node_count = 10,  **kwargs):\n\n\"\"\" Create a graph pipeline from a folder of images\n    Args:\n        path (str): Path to the folder containing the images\n        task (str): The task to be performed on the images. Currently only classification is supported\n        graph_method (str): The method to be used to create the graph. Currently only 'SLIC' is supported\n        feature_extractor (str): The feature extractor to be used to create the graph. Currently only 'resnet18/efficientnet/densenet121' is supported\n        node_count (int): The number of nodes in the graph\n        kwargs: Additional arguments to be passed to the graph creation method, like the number of prcoessors to be used\n    Returns:\n        A dictionary of the images with the graph segment of the image, defaut ~/.cache/imgraph/output else as specified in the environment variable IMGRAPH_HOME\n\n    \"\"\"\n\n\n    print(\"Creating graph pipeline\")\n    global output_dir\n    global class_map\n    output_dir = osp.join(DEFAULT_CACHE_DIR, 'output')\n    if os.environ.get(ENV_IMGRAPH_HOME):\n        makedirs(os.environ.get(ENV_IMGRAPH_HOME))\n        output_dir = osp.join(os.environ.get(ENV_IMGRAPH_HOME), 'output')\n    else:\n        makedirs(DEFAULT_CACHE_DIR)\n\n\n    if task == 'classification':\n        image_path = path \n        image_files = get_directories_from_path(image_path)\n        image_categories = get_file_categoryies_from_path(image_files)\n        file_path_dictionary = {}\n        for train_test_val in image_categories:\n            cat_path = osp.join(image_path, train_test_val)\n            class_dirs = get_directories_from_path(cat_path)\n            classes = get_file_categoryies_from_path(class_dirs)\n            label_encoder.fit(classes)\n            class_map = dict(zip(classes,label_encoder.transform(classes)))\n            if train_test_val not in file_path_dictionary.keys():\n                file_path_dictionary[train_test_val] = {}\n            for class_name in classes:\n                class_files = []\n                class_path = osp.join(cat_path, class_name)\n                class_files = get_files_from_path(class_path)\n                if class_name not in file_path_dictionary[train_test_val].keys():\n                    file_path_dictionary[train_test_val][class_name] = {}\n                file_path_dictionary[train_test_val][class_name] = class_files\n        img_and_name = read_images_in_parallel(file_path_dictionary)\n        graph_and_name = get_graph(img_and_name, class_map,feature_extractor, node_count)\n\n    #     return ClassificationPipeline(path, graph_method, feature_extractor, **kwargs)\n    # elif task == 'segmentation':\n    #     from imgraph.pipeline.segmentation_pipeline import SegmentationPipeline\n    #     return SegmentationPipeline(path, graph_method, feature_extractor, **kwargs)\n    # elif task == 'detection':\n    #     from imgraph.pipeline.detection_pipeline import DetectionPipeline\n    #     return DetectionPipeline(path, graph_method, feature_extractor, **kwargs)\n    else:\n        raise ValueError(f'Invalid task: {task}')\n</code></pre>"}]}